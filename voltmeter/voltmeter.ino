#include <GyverINA.h>
#define MX1508_IN1_PIN 5  // пины драйвера двигателей
#define MX1508_IN2_PIN 6
// глобальные переменные
int16_t motorPwm = 0;   // заполнение ШИМ, подаваемое на мотор
const int potPin = A0;  // Пин, к которому подключен потенциометр

INA219 ina;                       // Стандартный набор параметров для Arduino модуля (0.1, 3.2, 0x40)
float b = 0;
float a = 0;
float c = 0;
float d = 0;

void setup() {
  // Открываем последовательный порт
  Serial.begin(115200);
  Serial.print(F("INA219..."));

  // Проверяем наличие и инициализируем INA219
  if (ina.begin()) {
    Serial.println(F("connected!"));
  } else {
    Serial.println(F("not found!"));
    while (1);
  }

  // Можно веревести в режим сна, вызвав .sleep с аргументом true, чтобы разбудить - вызываем повторно с указанием false
  // ina.sleep(true);   // Усыпить INA219
  // ina.sleep(false);  // Разбудить INA219

  // INA219 имеет возможность встроенной калибровки измерения тока, при помощи специального калибровочного значения
  // После запуска библиотека автоматически рассчитает и запишет калибровочное значение на основе введенных данных
  // Полученное значение можно прочитать, используя метод .getCalibration(); для изменения и/или сохранения в EEPROM
  Serial.print(F("Calibration value: ")); Serial.println(ina.getCalibration());
  // Далее полученное значение можно изменять для подстройки под реальное сопротивление шунта и сохранять в EEPROM
  // Чтобы записать калибровочное значение в INA219 существует метод .setCalibration(value);
  // ina.setCalibration(ina.getCalibration() + 10); // Прочитать-модифицировать-записать калибровочное значение
  // Так же, можно использовать метод .adjCalibration(offset); для подстройки калибровки без непосредственного чтения
  // ina.adjCalibration(10);  // Увеличить калибровочное значение на 10
  // ina.adjCalibration(-20); // Уменьшить калибровочное значение на 20
  // Можно хранить в EEPROM и загружать в INA219 именно смещение калибровки вместо непосредственного значения

  // Так же имеется возможность выбрать разрешение АЦП (9-12 Бит) и включить встроенное усреднение измерений
  // Выбор настроек для измерения напряжения и тока разделены и определяются константами INA219_VBUS или INA219_VSHUNT
  // Усреднение увеличивает время измерений, снижая шумы измерений, доступно только для 12ти битного режима
  // ina.setResolution(INA219_VBUS, INA219_RES_10BIT); // Измеряем напряжение в 10ти битном режиме, 12 бит по умолчанию
  // Использование пониженного разрешения ускоряет измерения (см. таблицу в INA219.h), но НЕ рекомендуется
  // Использование встроенного усреднения крайне рекомендуется для повышения стабильности показаний на шумной нагрузке
  ina.setResolution(INA219_VBUS, INA219_RES_12BIT_X4);      // Напряжение в 12ти битном режиме + 4х кратное усреднение
  ina.setResolution(INA219_VSHUNT, INA219_RES_12BIT_X128);  // Ток в 12ти битном режиме + 128х кратное усреднение
  
  pinMode(MX1508_IN1_PIN, OUTPUT);
  pinMode(MX1508_IN2_PIN, OUTPUT);
  Serial.println("");
}

void loop() {
  // Читаем напряжение

  Serial.print(ina.getVoltage(), 3);
  Serial.print(',');



  Serial.println(ina.getCurrent(), 3);


  c = (ina.getCurrent());

  if (c>d) {d = c;}



  int potValue = analogRead(potPin);            // Считываем значение с потенциометра
  setMotorPwm(map(potValue, 0, 1023, 0, 255));  // Преобразуем значение в диапазон скорости мотора (0-255)
  delay(100);
}
void setMotorPwm(int16_t pwm) {  // функция подающая ШИМ на драйвер двигателей MX1508
  if (pwm >= 0) {

    analogWrite(MX1508_IN1_PIN, LOW);
    analogWrite(MX1508_IN2_PIN, abs(pwm));
  } else {
    analogWrite(MX1508_IN1_PIN, abs(pwm));
    analogWrite(MX1508_IN2_PIN, LOW);
  }
}